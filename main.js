'strict';

const https = require('https');
const log4js = require('log4js');
const cron = require('node-cron');
const request = require('request');
const appConfig = require('./config.json');
const logger = log4js.getLogger('MikrotikReleaseGetter');
const fs = require('fs');

const tls = require('tls');
const path = require('path');
const async = require('async');
const crypto = require('crypto');
let certFilePath;
log4js.configure(appConfig.logger);
logger.info('Starting');

createDirectory(appConfig.downloadPath);
updateSSLCert();

const httpOptions = {
    host: appConfig.web.host,
    path: appConfig.web.path,
    encoding: 'binary',
    method: 'GET'
};

/* Regex list */

/**
 * @const {string} downloadlinks - Regex pattern to match
 */
const longtermRelease = />(?<release>[0-9a-zA-Z\.]+)\s\(L/gm;
/**
 * @const {string} downloadlinks - Regex pattern to match
 */
const stableRelease = />(?<release>[0-9a-zA-Z\.]+)\s\(S/gm;
/**
 * @const {string} downloadlinks - Regex pattern to match
 */
const testingRelease = />(?<release>[0-9a-zA-Z\.]+)\s\(T/gm;
/**
 * @const {string} downloadlinks - Regex pattern to match
 */
const developmentRelease = />(?<release>[0-9a-zA-Z\.]+)\s\(D/gm;

const releases = {
    longterm: {
        version: '',
        rawurls: [],
        urls: [],
        sha256: [],
        objs: []
    },
    stable: {
        version: '',
        rawurls: [],
        urls: [],
        sha256: [],
        objs: []
    },
    testing: {
        version: '',
        rawurls: [],
        urls: [],
        sha256: [],
        objs: []
    },
    development: {
        version: '',
        rawurls: [],
        urls: [],
        sha256: [],
        objs: []
    }
};


process.stdin.resume(); // so the program will not close instantly

/**
 *
 * @param {*} options
 * @param {*} exitCode
 * @description This function handles the exiting of the application
 */
function exitHandler(options, exitCode) {
    const msg = {
        signal: options.type,
        description: options.description,
        exitcode: exitCode
    };
    logger.debug(msg);
    if (options.exit) {
        process.exit();
    }
}

// do something when app is closing
// process.on('exit', exitHandler.bind(null, { cleanup: true, type: 'ENDING', description: 'Application ending' }));
process.on('exit', (code) => {
    const msg = { cleanup: true, type: 'exit', code: code };
    logger.debug('Application shut down: ' + JSON.stringify(msg));
});
// catches ctrl+c event
process.on('SIGINT', exitHandler.bind(null, { exit: true, type: 'SIGINT', description: 'SIGINT is generated by the user pressing Ctrl+C and is an interrupt' }));
// catches "kill pid" (for example: nodemon restart)
process.on('SIGUSR1', exitHandler.bind(null, { exit: true, type: 'SIGUSR1', description: 'The SIGUSR1 signal is sent to a process to indicate user-defined conditions' }));
process.on('SIGUSR2', exitHandler.bind(null, { exit: true, type: 'SIGUSR2', description: 'The SIGUSR2 signal is sent to a process to indicate user-defined conditions' }));
// catches uncaught exceptions
process.on('uncaughtException', (error) => {
    const msg = {
        exit: true,
        type: error.name,
        description: error.message,
        stack: error.stack
    };
    exitHandler.bind(null, msg);
    logger.debug(msg);
    process.exit(1);
});

/**
 *
 * @param {string} pathstr
 * @description description
 */
function createDirectory(pathstr) {
    if (fs.existsSync(pathstr)) {
        logger.debug('Path "' + pathstr + '" exists');
    } else {
        logger.debug('Path "' + pathstr + '" does not exist, creating it...');
        fs.mkdirSync(pathstr);
    }
}

/**
 *
 */
function updateSSLCert() {
    certFilePath = path.join(__dirname, 'cert.pem');
    const tlsData = tls.rootCertificates.join('\n');
    fs.writeFileSync(certFilePath, tlsData);
}

/**
 *
 * @param {string} line
 * @description description
 */
function getReleases(line) {
    const reExec1 = longtermRelease.exec(line);
    if (reExec1) {
        releases.longterm.version = reExec1.groups.release;
    }
    const reExec2 = stableRelease.exec(line);
    if (reExec2) {
        releases.stable.version = reExec2.groups.release;
    }
    const reExec3 = testingRelease.exec(line);
    if (reExec3) {
        releases.testing.version = reExec3.groups.release;
    }
    const reExec4 = developmentRelease.exec(line);
    if (reExec4) {
        releases.development.version = reExec4.groups.release;
    }
}

/**
 *
 * @param {string} localFile
 * @return {boolean}
 */
function checkIfFileExists(localFile) {
    let fileRes = false;
    try {
        const stats = fs.statSync(localFile);
        if (stats.size) {
            fileRes = true;
        }
    } catch (err) {
        if (err.code != 'ENOENT') {
            logger.error('Problem with checking file "' + localFile + '":' + JSON.stringify(err));
        }
    }
    return fileRes;
}

/**
 *
 * @param {*} filename
 * @return {*}
 */
function getFileStats(filename) {
    try {
        const stats = fs.statSync(filename);
        return stats.size;
    } catch (err) {
        logger.error('Problem getting stats for file "' + localFile + '":' + JSON.stringify(err));
    }
    return false;
}


/**
 *
 * @param {*} localFile
 * @param {*} remotePath
 * @param {*} callback
 */
function download(localFile, remotePath, callback) {
    const localStream = fs.createWriteStream(localFile);
    const out = request({ uri: remotePath });
    out.on('response', function(resp) {
        if (resp.statusCode === 200) {
            out.pipe(localStream);
            localStream.on('close', function() {
                callback(null, localFile);
            });
        } else {
            callback(new Error('No file found at given url.'), null);
        }
    });
}

/**
 *
 * @param {string} uri
 * @param {string} rawPage
 * @return {object}
 */
function fileObject(uri, rawPage) {
    const fObj = {
        url: uri,
        filename: uri.split('/').reverse()[0],
        sha256: ''
    };

    const shaRegex = new RegExp('>' + fObj.filename + '</td><td>MD5</td><td>[a-zA-Z0-9]+</td></tr><tr><td>SHA256</td><td>(?<sha_1>[a-zA-Z0-9]+)</td>|<b>SHA256 </b>' + fObj.filename + ': (?<sha_2>[a-zA-Z0-9]+)<br', 'i');
    rawPage.forEach((line) => {
        const shaExec = shaRegex.exec(line);
        if (shaExec) {
            if (shaExec.groups.sha_1) {
                fObj.sha256 = shaExec.groups.sha_1;
            } else {
                fObj.sha256 = shaExec.groups.sha_2;
            }
        }
    });
    return fObj;
}

/**
 *
 * @param {*} objs
 * @param {*} path2
 */
function createSumsFile(objs, path2) {
    const sums = [];
    objs.forEach((element) => {
        sums.push(element.sha256 + ' *' + element.filename);
    });
    try {
        fs.writeFileSync(path2 + 'SHA256SUMS', sums.join('\n'), { encoding: 'utf8', flag: 'w' });
    } catch (e) {
        logger.error('Problem saving "' + path2 + 'SHA256SUMS" ' + JSON.stringify(e));
    }
}


/**
 *
 * @param {object} item
 * @return {object}
 */
function verifyFile(item) {
    const testfile = fs.readFileSync(item.filepath);
    const sha256sum = crypto.createHash('sha256').update(testfile).digest('hex');
    logger.debug('Checking hash of "' + item.filepath + '"');
    if (item.sha256 == sha256sum) {
        item.status = 'Hash matches';
    } else {
        item.status = 'Hash failed';
    }
    return item;
}

/* Cron that runs everyday at 23:00:00 */
cron.schedule(appConfig.cron, function() {
    logger.info('Running cron...');
    let str = '';
    const req = https.request(httpOptions, (res) => {
        // console.log(JSON.stringify(res));
        logger.debug('HTTP statusCode:', res.statusCode);
        /*         console.log(res.statusCode);
                console.log(res.statusMessage);
                console.log(res.method);
                console.log(res.path);
                console.log(res.host);
                console.log(res.protocol);
                console.log(res.headers); */
        res.on('data', (d) => {
            str += d;
        });
        res.on('end', function() {
            const contentData = str.replace(/td>/g, '\n').replace(/li>/g, '\n').split('\n');
            logger.info('Processing ' + contentData.length + ' lines');
            contentData.forEach((line) => {
                getReleases(line);
            });
            for (const prop in releases) {
                if (Object.prototype.hasOwnProperty.call(releases, prop)) {
                    if (releases[prop].version) {
                        releases[prop].objs = [];
                        logger.debug('Now working on release "' + releases[prop].version + '"');

                        createDirectory(appConfig.downloadPath + '/' + releases[prop].version);
                        const dlRegex = new RegExp('<a href="(?<filename>[a-zA-Z0-9:.\\-\\/]+' + releases[prop].version + '[a-zA-Z0-9:._\\-\\/]+)', 'gm');

                        contentData.forEach((line) => {
                            const reExec = dlRegex.exec(line);
                            if (reExec) {
                                releases[prop].rawurls.push(reExec.groups.filename);
                            }
                        });

                        releases[prop].urls = [...new Set(releases[prop].rawurls)];
                        releases[prop].urls.sort().forEach((element) => {
                            releases[prop].objs.push(fileObject(element, str.split('\n')));
                        });
                        async.forEach(releases[prop].objs, function(item, cb) {
                            const localFileName = item.filename;
                            const filename = appConfig.downloadPath + '/' + releases[prop].version + '/' + localFileName;
                            item.filepath = filename;
                            item.status = 'downloading';
                            item.size = 0;
                            if (!checkIfFileExists(filename) || appConfig.redownload) {
                                download(filename, item.url, function(err, result) {
                                    if (err) {
                                        logger.error('Problem downloading file:' + JSON.stringify(err));
                                    }
                                    if (result) {
                                        item.status = 'done';
                                        item.size = getFileStats(filename);
                                        item = verifyFile(item);
                                        logger.info(item);
                                    }
                                    cb();
                                });
                            }
                        }, function(err) {
                            logger.error('Problem downloading files:' + JSON.stringify(err));
                        });
                        createSumsFile(releases[prop].objs, appConfig.downloadPath + '/' + releases[prop].version + '/');
                    } else {
                        logger.debug('No version found for "' + prop + '"');
                    }
                }
            }
        });
    });

    req.on('error', (e) => {
        logger.error('Problem getting download page:' + JSON.stringify(e));
    });

    req.end();
});