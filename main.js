'strict';
/**
 * @typedef {Object} loggingConfiguration
 * @property {string} appenders Appenders serialise log events to some form of output
 * @property {string} categories The category (or categories if you provide an array of values) that will be excluded from the appender.
 * @description This defines the way the logger works
 */
/**
 * @typedef {Object} loggingOptions
 * @property {string} level The level of logging to use
 * @property {array} areas This is the various areas used for getLogger
 * @property {string} owner Application name
 * @description This object contains the configuration information for the logging subsystem
 */
/**
 * @typedef {object} ApplicationConfiguration
 * @property {loggingConfiguration} logger This defines the way the logger works
 * @property {loggingOptions} logging This object contains the configuration information for the logging subsystem
 * @property {messageBrokerServerSettings} messagebrokers This object contains the configuration information for the message broker sub system
 * @property {queueBase} queues This object contains the queue information for the message broker subsystem
 * @description Configuration from config.json
 */
/**
 * @property {ApplicationConfiguration} appConfig
 */
let appConfig;
const releasesObj = {};
let Logging;

/* Load internal libraries */
const Logger = require('commonfunctions').Logger;

const axios = require('axios');
const cheerio = require('cheerio');
const fs = require('fs');
const https = require('https');
const crypto = require('crypto');
const path = require('path');
const NodeHtmlMarkdown = require('node-html-markdown');
const nhm = new NodeHtmlMarkdown.NodeHtmlMarkdown({}, undefined, undefined);
const CronJob = require('cron').CronJob;
const tls = require('tls');


const DownloadLib = require('./lib/download.js');

/**
 *
 * @param {*} err String/object from sender
 * @description We use this to exit out of the application if fatal
 */
function bail(err) {
    console.error(err);
    process.exit(1);
}

/**
 *
 * @description Reads configuration from local file
 */
function loadConfigurationFile() {
    try {
        appConfig = JSON.parse(fs.readFileSync('./config.json', 'utf8'));
    } catch (err) {
        bail(err);
    }
}

/**
 *
 * @description Initialises the application
 */
function initialiseApplication() {
    loadConfigurationFile();
    Logging = new Logger(appConfig.logging);
    createDirectory(appConfig.downloadPath);
}

/**
 * Initialise the application
 */
initialiseApplication();

const downloader = new DownloadLib(Logging.downloader, appConfig.defaults.timeout);
updateSSLCert();

/**
 * @typedef {Object} exitOptions
 * @property {boolean} exit Is this an exit
 * @property {string} type What is the type that was called in order to exit the application
 * @property {string} description The description of the type of exit
 * @description This object contains the exit information of the application
 */

process.stdin.resume(); // so the program will not close instantly

/**
 *
 * @param {exitOptions} options This object contains the exit information of the application
 * @param {string} exitCode Exit code of application
 * @description This function handles the exiting of the application
 */
function exitHandler(options, exitCode) {
    const msg = {
        signal: options.type,
        description: options.description,
        exitcode: exitCode
    };

    Logging.system.debug(msg);
    if (options.exit) {
        process.exit();
    }
}

// do something when app is closing
process.on('exit', (code) => {
    const msg = { cleanup: true, type: 'exit', code: code };
    Logging.system.debug('Application shut down: ' + JSON.stringify(msg));
});
// catches ctrl+c event
process.on('SIGINT', exitHandler.bind(null, { exit: true, type: 'SIGINT', description: 'SIGINT is generated by the user pressing Ctrl+C and is an interrupt' }));
// catches "kill pid" (for example: nodemon restart)
process.on('SIGUSR1', exitHandler.bind(null, { exit: true, type: 'SIGUSR1', description: 'The SIGUSR1 signal is sent to a process to indicate user-defined conditions' }));
process.on('SIGUSR2', exitHandler.bind(null, { exit: true, type: 'SIGUSR2', description: 'The SIGUSR2 signal is sent to a process to indicate user-defined conditions' }));
// catches uncaught exceptions
process.on('uncaughtException', (error) => {
    const msg = {
        exit: true,
        type: error.name,
        description: error.message,
        stack: error.stack
    };
    exitHandler.bind(null, msg);
    Logging.system.error(msg);
    process.exit(1);
});

/**
 *
 * @param {array} releaselist
 * @param {array} urllist
 * @description description
 */
function buildReleaseURLList(releaselist, urllist) {
    releaselist.sort().forEach((release) => {
        const rawhash = releasesObj[release].rawhash;
        urllist.forEach((uri) => {
            const dlRegex = new RegExp('(?<filename>[a-zA-Z0-9:.\\-\\/]+' + release + '/[a-zA-Z0-9:._\\-\\/]+)', 'gm');
            const reExec = dlRegex.exec(uri);
            if (reExec) {
                const fObj = {
                    filename: uri.split('/').reverse()[0],
                    hashes: {
                        md5: '',
                        sha256: ''
                    },
                    localfile: appConfig.downloadPath + '/' + release + '/' + uri.split('/').reverse()[0],
                    status: false,
                    url: uri
                };
                const hashRegex = new RegExp('^' + fObj.filename + 'MD5(?<md5>[a-zA-Z0-9]{32})SHA256(?<sha256>[a-zA-Z0-9]{64})$', 'm');
                const reHash = hashRegex.exec(rawhash);
                if (reHash) {
                    fObj.hashes.sha256 = reHash.groups.sha256;
                    fObj.hashes.md5 = reHash.groups.md5;
                } else {
                    const hashRegex2 = new RegExp('MD5\\s' + fObj.filename + ': (?<md5>[a-zA-Z0-9]{32})SHA256\\s' + fObj.filename + ':\\s(?<sha256>[a-zA-Z0-9]{64})', 'i');
                    const reHash2 = hashRegex2.exec(rawhash);
                    if (reHash2) {
                        fObj.hashes.sha256 = reHash2.groups.sha256;
                        fObj.hashes.md5 = reHash2.groups.md5;
                    }
                }
                releasesObj[release].files.push(fObj);
            }
        });
        if (releasesObj[release].files.length) {
            getChangelog(release, 'releases');
        }
    });
}

/**
 *
 * @description This function updates the cert.pem file
 */
function updateSSLCert() {
    const certFilePath = path.join(__dirname, 'cert.pem');
    const tlsData = tls.rootCertificates.join('\n');
    fs.writeFileSync(certFilePath, tlsData);
}

/**
 *
 * @param {string} pathstr Target directory path
 * @description This function checks to see if there already exits a target path and if not, then create it
 */
function createDirectory(pathstr) {
    if (fs.existsSync(pathstr)) {
        Logging.fs.debug('Path "' + pathstr + '" exists');
    } else {
        Logging.fs.debug('Path "' + pathstr + '" does not exist, creating it...');
        fs.mkdirSync(pathstr);
    }
}

/**
 *
 * @param {string} hash Hash type
 * @param {fileObject} item This object contains the information needed to verify the downloaded file
 * @return {boolean}
 * @description This function checks to see that the download file's hash matches what was scrapped from the download page
 */
function verifyFileHash(hash, item) {
    const testfile = fs.readFileSync(item.localfile);
    const hashsum = crypto.createHash(hash).update(testfile).digest('hex');
    // / Logging.system.debug('Checking ' + hash + ' hash of "' + item.localfile + '"');
    if (item.hashes[hash] != '') {
        if (item.hashes[hash] == hashsum) {
            return true;
        }
    } else {
        return true;
    }
    return false;
}

/**
 *
 * @param {object} fileObj
 * @return {object}
 * @description description
 */
function validateFile(fileObj) {
    // / Logging.system.debug('Checking if "' + fileObj.localfile + '" exists');
    try {
        const stats = fs.statSync(fileObj.localfile);
        if (stats.size) {
            // / Logging.system.debug('Validating hash(es) "' + fileObj.localfile + '"');
            fileObj.status = verifyFileHash('sha256', fileObj);
            if (!fileObj.status) {
                fileObj.status = verifyFileHash('md5', fileObj);
            }
        }
    } catch (err) {
        Logging.fs.error('Problem with checking file "' + fileObj.localfile + '" => ' + JSON.stringify(err));
    }
    return fileObj;
}

/**
 *
 * @return {array}
 * @description description
 */
function buildDownloadList() {
    const downloadList = [];
    const dKeys = Object.keys(releasesObj).sort();
    dKeys.forEach((key) => {
        if (releasesObj.hasOwnProperty(key)) {
            const obj = releasesObj[key];
            if (obj.hasOwnProperty('files')) {
                if (obj.files.length) {
                    createDirectory(appConfig.downloadPath + '/' + key);
                    obj.files.forEach((element) => {
                        const tmp = validateFile(element);
                        if (!tmp.status) {
                            downloadList.push(tmp);
                        }
                    });
                }
                // //
            }
        }
    });
    // }
    return downloadList.sort((a, b) => (a.localfile > b.localfile) ? 1 : ((b.localfile > a.localfile) ? -1 : 0));
}

/**
 *
 * @param {string} release This is the release that will be searched for in order to get the changelog
 * @param {string} type
 * @description This function gets the changelog entries for teh supplied release
 */
function getChangelog(release, type) {
    let str = '';
    let extractedChangelog = '';

    const httpOptionsChangelogs = {
        host: appConfig.web[type].host,
        path: appConfig.web[type].changelog + release,
        encoding: 'binary',
        method: 'GET',
        starttime: new Date().valueOf()
    };
    const req = https.request(httpOptionsChangelogs, (res) => {
        res.on('data', (d) => {
            str += d;
        });
        res.on('end', function() {
            httpOptionsChangelogs.statuscode = res.statusCode;
            httpOptionsChangelogs.statusmessage = res.statusMessage;
            httpOptionsChangelogs.length = res.headers['content-length'];
            httpOptionsChangelogs.size = str.length;
            httpOptionsChangelogs.serverdatetime = res.headers.date;
            httpOptionsChangelogs.content_type = res.headers['content-type'];
            httpOptionsChangelogs.endtime = new Date().valueOf();
            httpOptionsChangelogs.timetaken = httpOptionsChangelogs.endtime - httpOptionsChangelogs.starttime;
            Logging.https.debug(JSON.stringify(httpOptionsChangelogs));
            extractedChangelog = str.split('\r\n');
            try {
                fs.writeFileSync(appConfig.downloadPath + '/' + release + '/' + 'CHANGELOG.md', nhm.translate(extractedChangelog.join('<br>')), { encoding: 'utf8', flag: 'w' });
            } catch (e) {
                Logging.fs.error('Problem saving "' + appConfig.downloadPath + '/' + release + '/' + 'CHANGELOG.md" ' + JSON.stringify(e));
            }
        });
    });

    req.on('error', (e) => {
        Logging.https.error('Problem getting download page:' + JSON.stringify(e));
    });

    req.end();
}

/**
 *
 * @return {object}
 * @description description
 */
function buildHashList() {
    const hashList = {};
    for (const key in releasesObj) {
        if (releasesObj.hasOwnProperty(key)) {
            const obj = releasesObj[key];
            hashList[key] = {};
            if (obj.hasOwnProperty('files')) {
                if (obj.files.length) {
                    obj.files.forEach((element) => {
                        for (const hashKey in element.hashes) {
                            if (element.hashes.hasOwnProperty(hashKey)) {
                                if (!hashList[key][hashKey]) {
                                    hashList[key][hashKey] = [];
                                }
                                hashList[key][hashKey].push({
                                    filename: element.filename,
                                    hash: element.hashes[hashKey]
                                });
                            }
                        }
                    });
                }
            }
        }
    }
    return hashList;
}

/**
 *
 * @param {string} filename
 * @param {string} data
 * @description description
 */
function writefile(filename, data) {
    try {
        fs.writeFileSync(filename, data);
    } catch (err) {
        Logging.fs.error('Problem with writing file "' + filename + '" => ' + JSON.stringify(err));
    }
}

/**
 *
 * @param {array} arrList
 * @return {string}
 * @description description
 */
function buildList(arrList) {
    let list = '';
    arrList.sort((a, b) => (a.filename > b.filename) ? 1 : ((b.filename > a.filename) ? -1 : 0));
    arrList.forEach((line) => {
        list += line.hash + '  ' + line.filename + '\n';
    });
    return list;
}

/**
 *
 * @param {string} release
 * @param {object} hashobject
 * @description description
 */
function buildHashFile(release, hashobject) {
    for (const hash in hashobject) {
        if (hashobject.hasOwnProperty(hash)) {
            const hashFileName = path.join(appConfig.downloadPath, release, hash.toUpperCase() + 'SUMS.txt');
            writefile(hashFileName, buildList(hashobject[hash]));
        }
    }
}

/**
 *
 * @param {object} hashlistobject
 * @description description
 */
function buildHashFiles(hashlistobject) {
    for (const key in hashlistobject) {
        if (Object.prototype.hasOwnProperty.call(hashlistobject, key)) {
            buildHashFile(key, hashlistobject[key]);
        }
    }
}

/**
 *
 * @param {string} url
 * @description description
 */
function getReleaseDownLoadURLs(url) {
    Logging.system.info('Getting page from :: ' + url);
    axios(url)
        .then((response) => {
            const html = response.data;
            const $ = cheerio.load(html);
            const rawreleases = [];
            const rawurls = [];
            /* Get list of releases */
            $('.downloadTable', html).each(function() {
                const url2 = $(this).find('thead').find('tr').text();
                const fff = url2.trim().replace(/\t/g, ' ').replace(/\s\s\s/g, ' ').split(' ');
                const regexPatternLongTermRelease = /(?<release>^[\d].[0-9a-zA-Z\\.]+)/gm;
                if (fff.length) {
                    fff.forEach((line) => {
                        const reExec1 = regexPatternLongTermRelease.exec(line);
                        if (reExec1) {
                            rawreleases.push(reExec1.groups.release);
                        }
                    });
                }
            });

            /* Get list of urls */
            const listItems = $('a');
            listItems.each(function(_idx, el) {
                const regexPattern = /(?<url>routeros)/gm;
                const reExec2 = regexPattern.exec($(el).attr('href'));
                if (reExec2) {
                    rawurls.push($(el).attr('href'));
                }
            });
            const sortedreleases = [...new Set(rawreleases)];
            const sortedurls = [...new Set(rawurls)];

            sortedreleases.forEach((release) => {
                releasesObj[release] = {
                    files: [],
                    rawhash: '',
                    filelist: []
                };
                const divName = release.replace(/\./g, '_');
                $('#md5_' + divName, html).each(function() {
                    releasesObj[release].rawhash = $(this).text();
                });
                $('#chmd5_' + divName, html).each(function() {
                    releasesObj[release].rawhash += $(this).text();
                });
            });

            buildReleaseURLList(sortedreleases, sortedurls);
            const dlist = buildDownloadList();
            buildHashFiles(buildHashList());
            downloader.fetchAllUrls(dlist);
        }).catch((err) => Logging.system.error(err));
}

/**
 * @constant
 * @todo Write the documentation.
 * @todo Implement this function.
 * @return {class}
 * @description Cronjob that is meant to run every hour on the hour for releases
 */
// eslint-disable-next-line no-unused-vars
const cronEveryHour = new CronJob(appConfig.cron.interval, function() {
    Logging.cron.info('Running interval: \'' + appConfig.cron.interval + '\'');
    getReleaseDownLoadURLs('https://' + appConfig.web.releases.host + appConfig.web.releases.path);
}, null, appConfig.cron.enabled, appConfig.cron.timezone);