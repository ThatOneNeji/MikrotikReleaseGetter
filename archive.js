'strict';
/**
 * @typedef {Object} queueBase
 * @property {string} consumeBaseName This is the base queue name to use for consume
 * @property {string} publishBaseName This is the base queue name to use for publish
 * @description This object contains the queue information for the message broker subsystem
 */
/**
 * @typedef {Object} loggingConfiguration
 * @property {string} appenders Appenders serialise log events to some form of output
 * @property {string} categories The category (or categories if you provide an array
 *     of values) that will be excluded from the appender.
 * @description This defines the way the logger works
 */
/**
 * @typedef {Object} loggingOptions
 * @property {string} level The level of logging to use
 * @property {array} areas This is the various areas used for getLogger
 * @property {string} owner Application name
 * @description This object contains the configuration information for the logging subsystem
 */
/**
 * @typedef {object} ApplicationConfiguration
 * @property {loggingConfiguration} logger This defines the way the logger works
 * @property {loggingOptions} logging This object contains the configuration information for the logging subsystem
 * @property {messageBrokerServerSettings} messagebrokers This object contains the configuration information for the message broker sub system
 * @property {queueBase} queues This object contains the queue information for the message broker subsystem
 * @description Configuration from config.json
 */
/**
 * @property {ApplicationConfiguration} appConfig
 */
let appConfig;

/* Load internal libraries */
const Logger = require('commonfunctions').Logger;

const axios = require('axios');
const cheerio = require('cheerio');
const fs = require('fs');
const https = require('https');
const crypto = require('crypto');
const path = require('path');
const NodeHtmlMarkdown = require('node-html-markdown');
const nhm = new NodeHtmlMarkdown.NodeHtmlMarkdown({}, undefined, undefined);
const CronJob = require('cron').CronJob;
const tls = require('tls');

const releasesObj = {};
const DownloadLib = require('./lib/download3.js');

let Logging;
let localDownloadPath;
const releasess = ['6.27', '6.28', '6.29', '6.30'];

/**
 * @function bail
 * @param {*} err String/object from sender
 * @description We use this to exit out of the application if fatal
 */
function bail(err) {
    console.error(err);
    process.exit(1);
}

/**
 * @function loadConfigurationFile
 * @description Reads configuration from local file
 */
function loadConfigurationFile() {
    try {
        appConfig = JSON.parse(fs.readFileSync('./config.json', 'utf8'));
    } catch (err) {
        bail(err);
    }
}

/**
 * @function initialiseApplication
 * @description Starts up the application
 */
function initialiseApplication() {
    loadConfigurationFile();
    Logging = new Logger(appConfig.logging);
    localDownloadPath = path.resolve(appConfig.web.archive.downloadPath);
    createDirectory(localDownloadPath);
}

/**
 * Initialise the application
 */
initialiseApplication();

const downloader = new DownloadLib(Logging.downloader);
updateSSLCert();

/* typedefs */
/**
 * @typedef {Object} exitOptions
 * @property {boolean} exit Is this an exit
 * @property {string} type What is the type that was called in order to exit the application
 * @property {string} description The description of the type of exit
 * @description This object contains the exit information of the application
 */

process.stdin.resume(); // so the program will not close instantly

/**
 *
 * @param {exitOptions} options This object contains the exit information of the application
 * @param {string} exitCode Exit code of application
 * @description This function handles the exiting of the application
 */
function exitHandler(options, exitCode) {
    const msg = {
        signal: options.type,
        description: options.description,
        exitcode: exitCode
    };
    Logging.system.debug(msg);
    if (options.exit) {
        process.exit();
    }
}

// do something when app is closing
process.on('exit', (code) => {
    const msg = { cleanup: true, type: 'exit', code: code };
    Logging.system.debug('Application shut down: ' + JSON.stringify(msg));
});
// catches ctrl+c event
process.on('SIGINT', exitHandler.bind(null, { exit: true, type: 'SIGINT', description: 'SIGINT is generated by the user pressing Ctrl+C and is an interrupt' }));
// catches "kill pid" (for example: nodemon restart)
process.on('SIGUSR1', exitHandler.bind(null, { exit: true, type: 'SIGUSR1', description: 'The SIGUSR1 signal is sent to a process to indicate user-defined conditions' }));
process.on('SIGUSR2', exitHandler.bind(null, { exit: true, type: 'SIGUSR2', description: 'The SIGUSR2 signal is sent to a process to indicate user-defined conditions' }));
// catches uncaught exceptions
process.on('uncaughtException', (error) => {
    const msg = {
        exit: true,
        type: error.name,
        description: error.message,
        stack: error.stack
    };
    exitHandler.bind(null, msg);
    Logging.system.debug(msg);
    process.exit(1);
});

/**
 * @description This function updates the cert.pem file
 */
function updateSSLCert() {
    const certFilePath = path.join(__dirname, 'cert.pem');
    const tlsData = tls.rootCertificates.join('\n');
    fs.writeFileSync(certFilePath, tlsData);
}

/**
 *
 * @param {string} pathstr Target directory path
 * @description This function checks to see if there already exits a target path and if not, then create it
 */
function createDirectory(pathstr) {
    if (!fs.existsSync(pathstr)) {
        // Logging.fs.debug('Path "' + pathstr + '" exists');
        // } else {
        Logging.fs.debug('Path "' + pathstr + '" does not exist, creating it...');
        fs.mkdirSync(pathstr);
    }
}

/**
 *
 * @param {string} hash Hash type
 * @param {fileObject} item This object contains the information needed to verify the downloaded file
 * @return {boolean}
 * @description This function checks to see that the download file's hash matches what was scrapped from the download page
 */
function verifyFileHash(hash, item) {
    const testfile = fs.readFileSync(item.localfile);
    const hashsum = crypto.createHash(hash).update(testfile).digest('hex');
    // / Logging.system.debug('Checking ' + hash + ' hash of "' + item.localfile + '"');
    if (item.hashes[hash] != '') {
        if (item.hashes[hash] == hashsum) {
            return true;
        }
    } else {
        return true;
    }
    return false;
}

/**
 *
 * @param {object} fileObj
 * @return {object}
 */
function validateFile(fileObj) {
    // / Logging.system.debug('Checking if "' + fileObj.localfile + '" exists');
    try {
        const stats = fs.statSync(fileObj.localfile);
        if (stats.size) {
            // / Logging.system.debug('Validating hash(es) "' + fileObj.localfile + '"');
            fileObj.status = verifyFileHash('sha256', fileObj);
            if (!fileObj.status) {
                fileObj.status = verifyFileHash('md5', fileObj);
            }
        }
    } catch (err) {
        // console.log(stats);
        Logging.fs.error('Problem while checking file "' + fileObj.localfile + '" => ' + JSON.stringify(err));
    }
    return fileObj;
}

/**
 *
 * @return {array}
 */
function buildDownloadList() {
    const downloadList = [];
    const dKeys = Object.keys(releasesObj).sort();
    dKeys.forEach((key) => {
        if (releasesObj.hasOwnProperty(key)) {
            //releasess.forEach((key) => {
            Logging.system.debug('Validating any files found for ' + key);
            const obj = releasesObj[key];
            if (obj.hasOwnProperty('files')) {
                if (obj.files.length) {
                    obj.files.forEach((element) => {
                        const tmp = validateFile(element);
                        if (!tmp.status) {
                            downloadList.push(tmp);
                        }
                    });
                }
            }
            //});
        }
    });

    return downloadList.sort((a, b) => (a.localfile > b.localfile) ? 1 : ((b.localfile > a.localfile) ? -1 : 0));
}

/**
 *
 * @param {string} release
 * @return {string}
 */
function buildChangelogCommand(release) {
    // appConfig.web.archive.changelog1+release
    const command = [];
    command.push('curl');
    command.push('--connect-timeout');
    command.push(appConfig.curl.connect_timeout);
    command.push('--max-time');
    command.push(appConfig.curl.max_time);
    command.push('-s');
    command.push('\'' + appConfig.web.archive.changelog + release + '\'');
    return command.join(' ');
}

/**
 *
 * @param {object} details
 * @return {string}
 */
function buildDownloadCommand(details) {
    const command = [];
    command.push('curl');
    command.push('--connect-timeout');
    command.push(appConfig.curl.connect_timeout);
    command.push('--max-time');
    command.push(appConfig.curl.max_time);
    command.push('-w "@curl-format.txt"');
    command.push('-s');
    command.push(details.url);
    command.push('-o');
    command.push(details.localfile);
    return command.join(' ');
}

/**
 *
 * @param {string} release This is the release that will be searched for in order to get the changelog
 * @description This function gets the changelog entries for teh supplied release
 */
function getChangelog(release) {
    Logging.system.debug('Getting changelog for ' + release);
    const changelogText = downloader.doRequest(buildChangelogCommand(release), 'Getting changelog for ' + release);
    const extractedChangelog = changelogText.result.split('\r\n');
    try {
        fs.writeFileSync(path.join(localDownloadPath, release, 'CHANGELOG.md'), nhm.translate(extractedChangelog.join('<br>')), { encoding: 'utf8', flag: 'w' });
    } catch (e) {
        Logging.fs.error('Problem saving "' + appConfig.downloadPath + '/' + release + '/' + 'CHANGELOG.md" ' + JSON.stringify(e));
    }
}

/**
 *
 * @param {string} key
 */
function getHashList(key) {
    const hashList = {};
    const rawhashArr = releasesObj[key].rawhash.split('\n');
    const newFiles = [];
    const regexPatternMD5 = />(?<filename>[a-z0-9\.\-\_]+)<\/td><td>MD5<\/td><td>(?<md5>[a-f0-9]{32})<\/td>/i;
    const regexPatternMD5SHA256 = />(?<filename>[a-z0-9\-\.\_]+)<\/td><td>MD5<\/td><td>(?<md5>[a-f0-9]{32})<\/td><\/tr><tr><td>SHA256<\/td><td>(?<sha256>[a-f0-9]{64})</i;

    rawhashArr.forEach((line) => {
        const reExec1 = regexPatternMD5SHA256.exec(line);
        if (reExec1) {
            hashList[reExec1.groups.filename] = {
                hashes: {
                    md5: reExec1.groups.md5,
                    sha256: reExec1.groups.sha256
                }
            };
        } else {
            const reExec2 = regexPatternMD5.exec(line);
            if (reExec2) {
                hashList[reExec2.groups.filename] = {
                    hashes: {
                        md5: reExec2.groups.md5,
                    }
                };
            } else {
                Logging.system.error('Failed to get any hashes for:' + line);
            }
        }
    });

    releasesObj[key].files.forEach((file) => {
        newFiles.push({...file, ...hashList[file.filename] });
    });
    releasesObj[key].files = newFiles.sort((a, b) => (a.filename > b.filename) ? 1 : ((b.filename > a.filename) ? -1 : 0));
}

/**
 *
 * @param {string} filename
 * @param {string} data
 */
function writefile(filename, data) {
    try {
        fs.writeFileSync(filename, data);
    } catch (err) {
        Logging.fs.error('Problem with writing file "' + filename + '" => ' + JSON.stringify(err));
    }
}

/**
 *
 * @param {array} arrList
 * @return {string}
 */
function buildList(arrList) {
    let list = '';
    arrList.sort((a, b) => (a.filename > b.filename) ? 1 : ((b.filename > a.filename) ? -1 : 0));
    arrList.forEach((line) => {
        list += line.hash + '  ' + line.filename + '\n';
    });
    return list;
}

/**
 *
 * @param {string} release
 * @param {object} hashobject
 */
function buildHashFiles(release, hashobject) {
    for (const hash in hashobject) {
        if (hashobject.hasOwnProperty(hash)) {
            if (hashobject[hash].length) {
                const hashFileName = path.join(localDownloadPath, release, hash.toUpperCase() + 'SUMS.txt');
                writefile(hashFileName, buildList(hashobject[hash]));
            }
        }
    }
}

/**
 *
 * @param {*} release
 * @param {*} hashlistobject
 */
function buildHashLists(release, hashlistobject) {
    const hashes = {};
    hashlistobject.forEach((file) => {
        for (const hash in file.hashes) {
            if (file.hashes.hasOwnProperty(hash)) {
                if (!hashes[hash]) {
                    hashes[hash] = [];
                }
                hashes[hash].push({ filename: file.filename, hash: file.hashes[hash] });
            }
        }
    });
    buildHashFiles(release, hashes);
}

/**
 *
 */
function actionDownloads() {
    const downloadedFiles = [];
    // get hashes
    const dKeys = Object.keys(releasesObj).sort();
    dKeys.forEach((key) => {
        getHashList(key);
        createDirectory(path.join(localDownloadPath, key));
        getChangelog(key);
        buildHashLists(key, releasesObj[key].files);
    });

    // getHashList('7.1.5');
    /*releasess.forEach((element) => {
        getHashList(element);
        createDirectory(path.join(localDownloadPath, element));
        getChangelog(element);
        buildHashLists(element, releasesObj[element].files);
    });*/

    const dlist = buildDownloadList();

    if (dlist.length) {
        // FirstPass
        dlist.forEach((item) => {
            item.download = downloader.doRequest(buildDownloadCommand(item), 'Now downloading ' + item.filename);
            console.log(item.download);
            if (item.download.status && validateFile(item)) {
                Logging.downloader.info('Successfully downloaded ' + item.filename + '(' + item.download.timetaken + ')');
            } else {
                downloadedFiles.push(item);
            }
        });
    }

    if (downloadedFiles.length) {
        Logging.system.warn(downloadedFiles.length + ' file failed to download correctly, attempting to redownload them');
        while (downloadedFiles.length) {
            downloadedFiles.forEach((element) => {
                const downloadDD = downloader.doRequest(buildDownloadCommand(element), 'Re-downloading ' + element.filename);
                // console.log(downloadDD);
                console.log(downloadDD);
                if (downloadDD.status && validateFile(element)) {
                    Logging.downloader.info('Successfully downloaded ' + element.filename + '(' + downloadDD.timetaken + ')');
                    downloadedFiles.pop();
                } else {
                    Logging.downloader.warn('Still failed');
                }
            });
        }
    }
}

/**
 *
 * @param {string} url
 */
function getDownLoadURLs(url) {
    Logging.system.debug('Getting archive page from ' + url);
    const rawHTML = fs.readFileSync('./tmp/archive2.html', 'utf8');
    /*    axios(url)
            .then((response) => {
                const html = response.data;
                const $ = cheerio.load(html);*/
    const $ = cheerio.load(rawHTML);
    let releaseName = '';

    /* Get list of releases */
    Logging.system.debug('Getting list of releases');
    $('.accordion-navigation', rawHTML).each(function() {
        /* $('.accordion-navigation', html).each(function() { */
        const releasenameRaw = $(this).find('a').find('b').text();
        const releasedateRaw = $(this).find('a').find('span').text();
        const regexPatternRelease = /^Release\s(?<release>[\d].[0-9a-zA-Z\.]+)/gm;
        const reExec1 = regexPatternRelease.exec(releasenameRaw);
        if (reExec1) {
            releaseName = reExec1.groups.release;
            if (!releasesObj[releaseName]) {
                // Logging.system.debug('Found release:' + releaseName);
                releasesObj[releaseName] = {
                    rawhash: '',
                    files: [],
                    changelog: '',
                    releasedate: releasedateRaw
                };
            }
        }

        $(this).find('a').each(function(idx, el) {
            // Logging.system.debug('Getting list of download URLs for:' + releaseName);
            const regexPattern = /(?<url>routeros)/gm;
            const reExec2 = regexPattern.exec($(el).attr('href'));
            if (reExec2) {
                const fileObj = {
                    filename: $(el).html(),
                    localfile: path.join(localDownloadPath, releaseName, $(el).html()),
                    url: $(el).attr('href'),
                    status: false
                };
                releasesObj[releaseName].files.push(fileObj);
            }
        });
        Logging.system.info('Found ' + releaseName + ' (' + releasesObj[releaseName].files.length + ' download URLs)');
        releasesObj[releaseName].rawhash = $(this).find('div').find('table').find('tr').find('td').find('div').find('table').html();
    });


    actionDownloads();
    Logging.system.info('done.');
    /* }).catch((err) => Logging.system.error(err)); */
}

/* cron.schedule(appConfig.cron, function() {
    Logging.system.info('Running cron...');
    getDownLoadURLs('https://' + appConfig.web.host + appConfig.web.path);
}); */


// eslint-disable-next-line no-unused-vars
/* const cronDDHH01SS = new CronJob(appConfig.cron.interval, function() {
    Logging.cron.info('Running interval: \'' + appConfig.cron.interval + '\'');
    getDownLoadURLs(appConfig.web.archive.url);
}, null, appConfig.cron.enabled, appConfig.cron.timezone); */

// archive.downloadPath

getDownLoadURLs(appConfig.web.archive.url);